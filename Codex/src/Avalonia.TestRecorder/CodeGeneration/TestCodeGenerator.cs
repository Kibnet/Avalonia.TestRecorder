using System.Globalization;
using System.Text;
using Avalonia;
using Avalonia.Input;

namespace Avalonia.TestRecorder;

internal sealed class TestCodeGenerator
{
    private readonly RecorderOptions _options;

    public TestCodeGenerator(RecorderOptions options)
    {
        _options = options;
    }

    public string Generate(RecordedTest test)
    {
        var ns = _options.Codegen.TestNamespace;
        var className = $"{_options.Codegen.ClassPrefix}_{Sanitize(test.ScenarioName)}_Tests";
        var methodName = $"Scenario_{test.RecordedAt:yyyyMMdd_HHmmss}";
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// Generated by Avalonia.TestRecorder");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Avalonia.Headless.XUnit;");
        sb.AppendLine("using Avalonia.HeadlessTestKit;");
        sb.AppendLine("using Avalonia.Input;");

        var appNs = GetNamespace(test.ApplicationTypeName);
        if (!string.IsNullOrWhiteSpace(appNs))
        {
            sb.AppendLine($"using {appNs};");
        }

        switch (_options.Codegen.TestFramework)
        {
            case TestFramework.Xunit:
                sb.AppendLine("using Xunit;");
                break;
            case TestFramework.NUnit:
                sb.AppendLine("using NUnit.Framework;");
                break;
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {ns};");
        sb.AppendLine();
        sb.AppendLine($"public sealed class {className}");
        sb.AppendLine("{");
        sb.AppendLine(_options.Codegen.TestFramework == TestFramework.NUnit
            ? "    [Test]"
            : "    [AvaloniaFact]");
        sb.AppendLine($"    public async Task {methodName}()");
        sb.AppendLine("    {");
        sb.AppendLine($"        await using var app = await HeadlessTestApplication.StartAsync<{test.ApplicationTypeName}, {test.WindowTypeName}>();");
        sb.AppendLine("        await app.RunAsync(async window =>");
        sb.AppendLine("        {");
        sb.AppendLine("            var ui = new Ui(window);");
        foreach (var step in test.Steps)
        {
            var warning = step.Warning ?? (!step.Target?.IsStable ?? false ? "WARNING: fallback selector" : null);
            if (warning is not null)
            {
                sb.AppendLine($"            // {warning}");
            }

            sb.AppendLine($"            {RenderStep(step)}");
        }

        sb.AppendLine("        });");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string RenderStep(RecordedStep step)
    {
        var selector = step.Target?.Value is { } s ? $"\"{Escape(s)}\"" : "\"<no-target>\"";
        var keyExpr = string.IsNullOrWhiteSpace(step.Key) ? "Key.None" : $"Key.{step.Key}";

        return step.Kind switch
        {
            RecordedStepKind.Click => $"await ui.ClickAsync({selector});",
            RecordedStepKind.DoubleClick => $"await ui.DoubleClickAsync({selector});",
            RecordedStepKind.RightClick => $"await ui.RightClickAsync({selector});",
            RecordedStepKind.Hover => $"await ui.HoverAsync({selector});",
            RecordedStepKind.Scroll => $"await ui.ScrollAsync({selector}, new Vector({Format(step.ScrollDelta?.X)}, {Format(step.ScrollDelta?.Y)}));",
            RecordedStepKind.TextInput => $"await ui.TypeTextAsync({selector}, \"{Escape(step.Text ?? string.Empty)}\");",
            RecordedStepKind.KeyPress => $"await ui.KeyPressAsync({selector}, {keyExpr}, {FormatModifiers(step.Modifiers)});",
            RecordedStepKind.AssertText => $"await ui.AssertTextAsync({selector}, \"{Escape(step.Expected ?? string.Empty)}\");",
            RecordedStepKind.AssertToggle => $"await ui.AssertToggleAsync({selector}, {FormatBool(step.ExpectedBool)});",
            RecordedStepKind.AssertVisible => $"await ui.AssertVisibleAsync({selector}, {FormatBool(step.ExpectedBool)});",
            RecordedStepKind.AssertEnabled => $"await ui.AssertEnabledAsync({selector}, {FormatBool(step.ExpectedBool)});",
            _ => "// Unsupported step"
        };
    }

    private static string Sanitize(string value)
    {
        var builder = new StringBuilder();
        foreach (var ch in value)
        {
            builder.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }

        var result = builder.ToString().Trim('_');
        return string.IsNullOrEmpty(result) ? "Scenario" : result;
    }

    private static string Escape(string value) => value.Replace("\\", "\\\\").Replace("\"", "\\\"");

    private static string GetNamespace(string fullTypeName)
    {
        var idx = fullTypeName.LastIndexOf('.');
        return idx <= 0 ? string.Empty : fullTypeName[..idx];
    }

    private static string Format(double? value) => (value ?? 0).ToString("0.0", CultureInfo.InvariantCulture);

    private static string FormatBool(bool? value) => (value ?? false) ? "true" : "false";

    private static string FormatModifiers(KeyModifiers modifiers)
    {
        if (modifiers == KeyModifiers.None)
        {
            return "KeyModifiers.None";
        }

        var parts = new List<string>();
        foreach (KeyModifiers mod in Enum.GetValues(typeof(KeyModifiers)))
        {
            if (mod == KeyModifiers.None)
            {
                continue;
            }

            if (modifiers.HasFlag(mod))
            {
                parts.Add($"KeyModifiers.{mod}");
            }
        }

        return string.Join(" | ", parts);
    }
}

public sealed class DefaultTemplateProvider : ITestTemplateProvider
{
    public string Render(RecordedTest test, RecorderOptions options)
    {
        return new TestCodeGenerator(options).Generate(test);
    }
}
